#include "mm_bt/perceive_world.h"
#include <cmath>

namespace perception {

PerceiveWorld::PerceiveWorld(ros::NodeHandle& nh, ros::NodeHandle& nh_private)
    : nh_(nh), nh_private_(nh_private), robot_yaw_(0.0), nav_status_received_(false) {
    
    robot_ned_.setZero();
    robot_gps_.setZero();
    
    loadParameters();
    initializeMissionMemory();
    loadDiscoveredBuoys();
    loadBuoyDatabase();
    
    // Publishers
    pub_opi_ = nh_.advertise<rami_msgs::OPIInfo>("/raasl_stack/perception/yolo_manager/OPI_topic", 10);
    pub_status_ = nh_.advertise<rami_msgs::NodeStatus>("/raasl_stack/perception/yolo_manager/getState", 10);
    
    // Subscribers
    sub_nav_status_ = nh_.subscribe("/nav_status", 1, &PerceiveWorld::navStatusCallback, this);
    sub_odom_ = nh_.subscribe("/base_pose_ground_truth", 1, &PerceiveWorld::odomCallback, this);
    
    // Timers
    timer_detection_ = nh_.createTimer(ros::Duration(0.2), &PerceiveWorld::detectionLoop, this);
    timer_status_ = nh_.createTimer(ros::Duration(1.0), &PerceiveWorld::publishStatus, this);
    
    // Generate world file if requested
    if (generate_world_on_startup_) {
        generateStageWorld();
    }
    
    ROS_INFO("=======================================================================");
    ROS_INFO("PERCEIVE WORLD NODE INITIALIZED");
    ROS_INFO("Loaded %lu buoys from mission_objects.yaml", buoys_.size());
    ROS_INFO("Detection: range=%.2fm, FOV=%.1fÂ°", detection_range_, detection_fov_);
    ROS_INFO("NED Origin: (%.8f, %.8f, %.2f)", ned_origin_(0), ned_origin_(1), ned_origin_(2));
    if (generate_world_on_startup_) {
        ROS_INFO("Generated Stage world: %s", world_file_path_.c_str());
    }
    ROS_INFO("=======================================================================");
}

void PerceiveWorld::loadParameters() {
    // NED origin
    nh_.param("/ned_origin/latitude", ned_origin_(0), 44.09613064612619);
    nh_.param("/ned_origin/longitude", ned_origin_(1), 9.865068083462063);
    nh_.param("/ned_origin/depth", ned_origin_(2), 0.0);
    
    // Detection parameters
    nh_.param("/detection_params/range", detection_range_, 1.0);
    nh_.param("/detection_params/fov", detection_fov_, 60.0);
    nh_.param("/detection_params/timeout", detection_timeout_, 1.5);
    
    // World file
    std::string default_world = std::string(getenv("HOME")) + "/btree_ws/src/mm_bt/config/RAMI_area_1.world";
    nh_private_.param("world_file_path", world_file_path_, default_world);
    nh_private_.param("generate_world", generate_world_on_startup_, true);
    
    // Mission memory file
    std::string default_memory = std::string(getenv("HOME")) + "/btree_ws/src/mm_bt/config/mission_memory.yaml";
    nh_private_.param("mission_memory_file", mission_memory_file_, default_memory);
}

void PerceiveWorld::loadBuoyDatabase() {
    XmlRpc::XmlRpcValue buoys_config;
    if (!nh_.getParam("/mission_objects/buoys", buoys_config)) {
        ROS_ERROR("No buoys found in mission_objects.yaml!");
        return;
    }
    
    for (XmlRpc::XmlRpcValue::iterator it = buoys_config.begin(); it != buoys_config.end(); ++it) {
        std::string buoy_name = it->first;
        XmlRpc::XmlRpcValue& config = it->second;
        
        BuoyData buoy;
        buoy.name = buoy_name;
        buoy.gps(0) = static_cast<double>(config["latitude"]);
        buoy.gps(1) = static_cast<double>(config["longitude"]);
        buoy.gps(2) = static_cast<double>(config["depth"]);
        buoy.fiducial_id = static_cast<int>(config["fiducial_id"]);
        buoy.color = static_cast<std::string>(config["color"]);
        buoy.label = static_cast<std::string>(config["label"]);
        
        // Convert GPS to NED using raasl_toolbox
        Eigen::Vector2d latlon(buoy.gps(0), buoy.gps(1));
        Eigen::Vector2d origin_latlon(ned_origin_(0), ned_origin_(1));
        Eigen::Vector2d ne = RAASL::Geo::LatLon2NE(origin_latlon, latlon);
        buoy.ned = Eigen::Vector3d(ne(0), ne(1), buoy.gps(2));
        
        buoys_[buoy.fiducial_id] = buoy;
        
        ROS_INFO("Loaded buoy '%s': GPS(%.6f, %.6f) -> NED(%.2fm N, %.2fm E)",
                 buoy_name.c_str(), buoy.gps(0), buoy.gps(1), buoy.ned(0), buoy.ned(1));
    }
}

void PerceiveWorld::generateStageWorld() {
    std::ofstream file(world_file_path_.c_str());
    if (!file.is_open()) {
        ROS_ERROR("Failed to open world file: %s", world_file_path_.c_str());
        return;
    }
    
    // Header
    file << "# RAMI_area_1.world - Auto-generated by perceive_world\n";
    file << "# Generated at: " << ros::Time::now() << "\n";
    file << "# NED Origin: (" << ned_origin_(0) << ", " << ned_origin_(1) << ")\n\n";
    
    // Static definitions
    file << "include \"pioneer.inc\"\ninclude \"map.inc\"\ninclude \"sick.inc\"\n\n";
    file << "resolution 0.02\ninterval_sim 100\n\n";
    
    // Buoy model definition
    file << "define buoy model\n(\n";
    file << "  size [0.3 0.3 1.0]\n";
    file << "  fiducial\n  (\n";
    file << "    range_max " << (detection_range_ + 0.2) << "\n";
    file << "    fov " << detection_fov_ << "\n";
    file << "  )\n";
    file << "  fiducial_return 1\n)\n\n";
    
    // Add buoys
    std::map<std::string, std::string> color_map;
    color_map["yellow"] = "yellow";
    color_map["white"] = "white";
    color_map["black"] = "gray10";
    color_map["red"] = "red";
    
    for (std::map<int, BuoyData>::const_iterator it = buoys_.begin(); it != buoys_.end(); ++it) {
        int fid = it->first;
        const BuoyData& buoy = it->second;
        
        std::string color = "gray50";
        if (color_map.find(buoy.color) != color_map.end()) {
            color = color_map[buoy.color];
        }
        
        file << "buoy\n(\n";
        file << "  pose [" << buoy.ned(0) << " " << buoy.ned(1) << " 0 0]\n";
        file << "  name \"" << buoy.name << "\"\n";
        file << "  fiducial_key " << fid << "\n";
        file << "  color \"" << color << "\"\n)\n\n";
    }
    
    file.close();
    ROS_INFO("Stage world file generated: %s", world_file_path_.c_str());
}

void PerceiveWorld::initializeMissionMemory() {
    YAML::Node memory;
    memory["mission_start_time"] = ros::Time::now().toSec();
    memory["discovered_buoys"] = YAML::Node(YAML::NodeType::Sequence);
    
    std::ofstream file(mission_memory_file_.c_str());
    file << memory;
    file.close();
    
    ROS_INFO("Mission memory initialized: %s", mission_memory_file_.c_str());
}

void PerceiveWorld::loadDiscoveredBuoys() {
    try {
        YAML::Node memory = YAML::LoadFile(mission_memory_file_);
        if (memory["discovered_buoys"]) {
            for (size_t i = 0; i < memory["discovered_buoys"].size(); ++i) {
                discovered_buoys_memory_.insert(memory["discovered_buoys"][i]["label"].as<std::string>());
            }
            ROS_INFO("Loaded %lu discovered buoys from memory", discovered_buoys_memory_.size());
        }
    } catch (const std::exception& e) {
        ROS_WARN("Could not load discovered buoys: %s", e.what());
    }
}

void PerceiveWorld::saveDiscoveredBuoy(int buoy_id) {
    const BuoyData& buoy = buoys_[buoy_id];
    if (discovered_buoys_memory_.count(buoy.label)) return;
    
    discovered_buoys_memory_.insert(buoy.label);
    
    try {
        YAML::Node memory = YAML::LoadFile(mission_memory_file_);
        YAML::Node entry;
        entry["label"] = buoy.label;
        entry["fiducial_id"] = buoy.fiducial_id;
        entry["latitude"] = buoy.gps(0);
        entry["longitude"] = buoy.gps(1);
        entry["depth"] = buoy.gps(2);
        entry["color"] = buoy.color;
        entry["name"] = buoy.name;
        entry["discovery_time"] = ros::Time::now().toSec();
        
        memory["discovered_buoys"].push_back(entry);
        
        std::ofstream file(mission_memory_file_.c_str());
        file << memory;
        file.close();
        
        ROS_INFO("=== BUOY DISCOVERED AND SAVED TO MEMORY: %s ===", buoy.label.c_str());
    } catch (const std::exception& e) {
        ROS_ERROR("Failed to save discovered buoy: %s", e.what());
    }
}

void PerceiveWorld::navStatusCallback(const marta_msgs::NavStatus::ConstPtr& msg) {
    nav_status_ = *msg;
    nav_status_received_ = true;
    
    robot_gps_(0) = msg->position.latitude;
    robot_gps_(1) = msg->position.longitude;
    robot_gps_(2) = msg->position.depth;
    robot_yaw_ = msg->orientation.yaw;
    
    // Convert to NED
    Eigen::Vector2d latlon(robot_gps_(0), robot_gps_(1));
    Eigen::Vector2d origin(ned_origin_(0), ned_origin_(1));
    Eigen::Vector2d ne = RAASL::Geo::LatLon2NE(origin, latlon);
    robot_ned_ = Eigen::Vector3d(ne(0), ne(1), robot_gps_(2));
}

void PerceiveWorld::odomCallback(const nav_msgs::Odometry::ConstPtr& msg) {
    if (nav_status_received_) return;  // Prefer NavStatus
    
    // Fallback: use Stage odometry as NED
    robot_ned_(0) = msg->pose.pose.position.x;
    robot_ned_(1) = msg->pose.pose.position.y;
    robot_ned_(2) = 0.0;
    
    // Extract yaw from quaternion
    const geometry_msgs::Quaternion& q = msg->pose.pose.orientation;
    robot_yaw_ = std::atan2(2.0 * (q.w * q.z + q.x * q.y), 1.0 - 2.0 * (q.y * q.y + q.z * q.z));
    
    // Convert to GPS
    Eigen::Vector2d ne(robot_ned_(0), robot_ned_(1));
    Eigen::Vector2d origin(ned_origin_(0), ned_origin_(1));
    Eigen::Vector2d latlon = RAASL::Geo::NE2LatLon(origin, ne);
    robot_gps_(0) = latlon(0);
    robot_gps_(1) = latlon(1);
    robot_gps_(2) = 0.0;
}

void PerceiveWorld::detectionLoop(const ros::TimerEvent& event) {
    if (robot_ned_.norm() == 0.0) {
        ROS_WARN_THROTTLE(10.0, "Waiting for robot position");
        return;
    }
    
    ros::Time current_time = ros::Time::now();
    
    // Check each buoy
    for (std::map<int, BuoyData>::const_iterator it = buoys_.begin(); it != buoys_.end(); ++it) {
        int buoy_id = it->first;
        const BuoyData& buoy = it->second;
        
        double delta_n = buoy.ned(0) - robot_ned_(0);
        double delta_e = buoy.ned(1) - robot_ned_(1);
        double distance = std::sqrt(delta_n * delta_n + delta_e * delta_e);
        
        double bearing = std::atan2(delta_e, delta_n);
        double angle_diff = RAASL::Angles::wrapToPi(bearing - robot_yaw_);
        double fov_rad = RAASL::Angles::deg2rad(detection_fov_ / 2.0);
        
        bool in_range = distance <= detection_range_;
        bool in_fov = std::abs(angle_diff) <= fov_rad;
        bool detected = in_range && in_fov;
        
        if (detected) {
            bool was_new = detected_buoys_.count(buoy_id) == 0;
            detected_buoys_[buoy_id] = current_time;
            
            if (was_new) {
                saveDiscoveredBuoy(buoy_id);
            }
        }
    }
    
    // Clean expired detections
    std::map<int, ros::Time>::iterator it = detected_buoys_.begin();
    while (it != detected_buoys_.end()) {
        if ((current_time - it->second).toSec() > detection_timeout_) {
            detected_buoys_.erase(it++);
        } else {
            ++it;
        }
    }
    
    // Publish if any detected
    if (!detected_buoys_.empty()) {
        publishOPIMessage();
    }
}

void PerceiveWorld::publishOPIMessage() {
    rami_msgs::OPIInfo msg;
    
    // NavStatus
    if (nav_status_received_) {
        msg.nav_status = nav_status_;
    } else {
        msg.nav_status.position.latitude = robot_gps_(0);
        msg.nav_status.position.longitude = robot_gps_(1);
        msg.nav_status.position.depth = robot_gps_(2);
        msg.nav_status.orientation.yaw = robot_yaw_;
    }
    
    // Sort by fiducial_id
    std::vector<int> sorted_ids;
    for (std::map<int, ros::Time>::const_iterator it = detected_buoys_.begin(); 
         it != detected_buoys_.end(); ++it) {
        sorted_ids.push_back(it->first);
    }
    std::sort(sorted_ids.begin(), sorted_ids.end());
    
    for (size_t i = 0; i < sorted_ids.size(); ++i) {
        int buoy_id = sorted_ids[i];
        const BuoyData& buoy = buoys_[buoy_id];
        
        geometry_msgs::Point geo_point;
        geo_point.x = buoy.gps(0);  // latitude
        geo_point.y = buoy.gps(1);  // longitude
        geo_point.z = buoy.gps(2);  // depth
        
        msg.geo_coords.push_back(geo_point);
        msg.type_OPI.push_back(buoy.label);
        msg.cam_coords.push_back(geometry_msgs::Point());
        msg.body_coords.push_back(geometry_msgs::Point());
    }
    
    msg.camera_id = "stage_simulator";
    pub_opi_.publish(msg);
}

void PerceiveWorld::publishStatus(const ros::TimerEvent& event) {
    rami_msgs::NodeStatus msg;
    msg.header.stamp = ros::Time::now();
    msg.node_status = "ACTIVE";
    pub_status_.publish(msg);
}

} // namespace perception

int main(int argc, char** argv) {
    ros::init(argc, argv, "perceive_world");
    ros::NodeHandle nh;
    ros::NodeHandle nh_private("~");
    
    perception::PerceiveWorld node(nh, nh_private);
    ros::spin();
    
    return 0;
}

